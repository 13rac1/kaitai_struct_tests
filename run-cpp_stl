#!/usr/bin/env ruby

require 'fileutils'

class ShellConfig
  def initialize(filename)
    @entries = {}
    File.open(filename, 'r') { |f|
      f.each_line { |l|
        l.chomp!
        l.strip!
        l.gsub!(/#.*$/, '')
        if l =~ /^([A-Za-z0-9_])=(.*?)$/
          @entries[$1] = $2
        end
      }
    }
  end

  def [](key)
    @entries[key]
  end
end

class RunCpp
  def initialize(src_dir, cpp_spec_dir, cpp_test_out_dir)
    @config = ShellConfig.new('config')

    @src_dir = src_dir
    @cpp_spec_dir = cpp_spec_dir
    @cpp_test_out_dir = cpp_test_out_dir

    @obj_dir = "#{@src_dir}/bin"
    @spec_cmake = "#{@obj_dir}/spec_files.cmake"
    @compiled_cmake = "#{@obj_dir}/compiled_files.cmake"
    @abs_cpp_test_out_dir = File.absolute_path(@cpp_test_out_dir)
    @test_dir = Dir.pwd
  end

  def run
    FileUtils.mkdir_p(@obj_dir)
    FileUtils.mkdir_p(@abs_cpp_test_out_dir)

    Dir.chdir(@obj_dir)

    init_file_lists
    init_cmake or raise "Failed to initialize CMake"
    build_all or raise "Failed to finish a build"
    run_tests or raise "Failed to run tests"
  end

  # Create initial list of files to compile, starting with everything
  def init_file_lists
    puts 'init_file_lists'

    init_file_list(@cpp_spec_dir, 'SPEC_SOURCES', @spec_cmake)
    init_file_list(@src_dir, 'KS_SOURCES', @compiled_cmake)
  end

  def init_file_list(dir, cmake_var, out_file)
    sources = Dir.glob("#{dir}/**/*.cpp").sort
    puts "init_file_list: #{cmake_var} in #{out_file} => #{sources.size} entries"

    File.open(out_file, 'w') { |f|
      f.puts("set(#{cmake_var}")
      sources.each { |l| f.puts(l) }
      f.puts(")")
    }
  end

  # Init CMake, generate platform-specific Makefile / project files
  def init_cmake
    puts 'init_cmake'

    cmake_cli = [
      "cmake",
      "-DCMAKE_BUILD_TYPE=Debug",
      "-DINC1_PATH=#{@spec_cmake}",
      "-DINC2_PATH=#{@compiled_cmake}",
      "-DKS_PATH=#{@src_dir}",
    ]

    # Building on Appveyor/Windows requires extra argument to CMake
    if ENV['APPVEYOR']
      cmake_cli << "-DCMAKE_TOOLCHAIN_FILE=c:/tools/vcpkg/scripts/buildsystems/vcpkg.cmake"

      # TODO: decide on architecture based on extra env variable
      cmake_cli << "-DCMAKE_GENERATOR_PLATFORM=x64"
    end

    cmake_cli << @cpp_spec_dir

    puts "cmake_cli = #{cmake_cli.inspect}"
    flush_all

    system(*cmake_cli)
  end

  def build_all
    puts "build_all"
    debug_cwd

    if compile_everything
      # all good, compile finished
      puts 'build_all: DONE'
    else
      # try to fix up by removing some files from compilation
      compile_failures_seq
      puts 'build_all: FAILED, trying to resolve by linking successfully compiled things...'
      if system("ruby", "#{@test_dir}/link-cpp_stl", ".", @abs_cpp_test_out_dir)
	puts 'build_all: DONE partially'
      else
	puts 'build_all: FAILED'
        return false
      end
    end

    return true
  end

  # Compile everything:
  # 1. KS runtime part for C++/STL
  # 2. Binary format parser sources, generated by KS compiler
  # 3. Test specs
  def compile_everything
    puts 'compile_everything: Building project generated with CMake...'
    flush_all

    if File.exists?('Makefile')
      system("LC_ALL=en_US.UTF-8 make -j8 -k >\"#{@abs_cpp_test_out_dir}/make.stdout\" 2>\"#{@abs_cpp_test_out_dir}/make.stderr\"")
    elsif File.exists?('KS_TEST_CPP_STL.sln')
      system("msbuild KS_TEST_CPP_STL.sln -fl -flp:logfile=#{@abs_cpp_test_out_dir}\\msbuild.log")
    else
      debug_cwd
      raise "No build makefile/project file found, unable to continue."
    end
  end

  def compile_failures_seq
    puts 'compile_failures_seq: Building project generated with CMake (sequentially)...'
    flush_all

    if File.exists?('Makefile')
      system("LC_ALL=en_US.UTF-8 make -k >\"#{@abs_cpp_test_out_dir}/make.stdout\" 2>\"#{@abs_cpp_test_out_dir}/make.stderr\"")
    elsif File.exists?('KS_TEST_CPP_STL.sln')
      system("msbuild KS_TEST_CPP_STL.sln -fl -flp:logfile=#{@abs_cpp_test_out_dir}\\msbuild.log")
    else
      debug_cwd
      raise "No build makefile/project file found, unable to continue"
    end
  end

  def run_tests
    puts "run_tests"

    # Work around boost v1.62 bug: https://svn.boost.org/trac10/ticket/12507
    # --log_sink is broken in boost v1.62, using workaround, as per
    # https://stackoverflow.com/a/39999085/487064
    #
    # However, Travis has boost v1.54, which has problems with it, so we
    # won't use the workaround on anything except exactly v1.62

    boost_log_option = "--log_sink=#{@cpp_test_out_dir}/results.xml"

    begin
      if File.read('/usr/include/boost/version.hpp') =~ /BOOST_VERSION 106200/
        # Boost v1.62 detected, enabling workaround
        boost_log_option = "--logger=JUNIT,test_suite,#{@cpp_test_out_dir}/results.xml"
      end
    rescue Errno::ENOENT => e
      # ignore
    end

    puts "boost_log_option = #{boost_log_option.inspect}"

    # Actually run the tests
    Dir.chdir(@test_dir)
    flush_all
    system(
      "#{@obj_dir}/ks_tests",
      '--log_format=XML',
      boost_log_option,
      '--log_level=all',
      '--report_level=detailed'
    )
  end

  def flush_all
    $stdout.flush
    $stderr.flush
  end

  def debug_cwd
    flush_all
    puts "...... Current directory: #{Dir.pwd}"
    puts "...... Current dir listing:"
    system("ls -al")
  end
end

if ARGV.size != 3
  puts "#{$PROGRAM_NAME} <src_dir> <spec_dir> <test_out_dir>"
  exit 1
end

RunCpp.new(*ARGV).run
